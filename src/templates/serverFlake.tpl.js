export default {"compiler":[8,">= 4.3.0"],"main":function(container,depth0,helpers,partials,data) {
    var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "{\n  # Flake inputs\n  inputs = {\n      nixpkgs.url = \"github:NixOS/nixpkgs\";\n      flake-utils = { url = \"github:numtide/flake-utils\"; };\n  };\n\n  # Flake outputs\n  outputs = { self, nixpkgs, flake-utils }:\n  flake-utils.lib.eachDefaultSystem (system:\n  let\n    pkgs = import nixpkgs { inherit system; };\n\n    # Build Caddy\n    caddy = with pkgs; stdenv.mkDerivation rec {\n      pname = \"caddy\";\n      version = \"2.6.4\";\n      dontUnpack = true;\n      nativeBuildInputs = [ git go xcaddy ];\n      plugins = [\n        \"github.com/mholt/caddy-l4/layer4\"\n        \"github.com/mholt/caddy-l4/modules/l4http\"\n        \"github.com/mholt/caddy-l4/modules/l4proxy\"\n      ];\n\n      configurePhase = ''\n        export GOCACHE=$TMPDIR/go-cache\n        export GOPATH=\"$TMPDIR/go\"\n      '';\n\n      buildPhase = let\n        pluginArgs = lib.concatMapStringsSep \" \" (plugin: \"--with ${plugin}\") plugins;\n      in ''\n        runHook preBuild\n        ${xcaddy}/bin/xcaddy build \"v${version}\" ${pluginArgs}\n        runHook postBuild\n      '';\n\n      installPhase = ''\n        runHook preInstall\n        mkdir -p $out/bin\n        mv caddy $out/bin\n        runHook postInstall\n      '';\n    };\n\n    procfile = pkgs.writeText \"Procfile\" ''\n      caddy: '${caddy}/bin/caddy run'\n    '';\n\n    env.OVERMIND_SOCKET=\""
    + container.escapeExpression(container.lambda(((stack1 = (depth0 != null ? lookupProperty(depth0,"config") : depth0)) != null ? lookupProperty(stack1,"statePath") : stack1), depth0))
    + "/nudxserver.sock\";\n\n    # SCRIPT - Get service PID\n    getServicePidScript = pkgs.writeShellScriptBin \"getServicePid\" ''\n      ${pkgs.overmind}/bin/overmind status -s ${env.OVERMIND_SOCKET} | awk -v service=\"$1\" '$1 == service { print $2 }'\n    '';\n\n    # SCRIPT - Stop Server\n    stopServer = pkgs.writeShellScriptBin \"stopServer\" ''\n      OVERMIND_PROCFILE=${procfile}\n      if [[ -S \"${env.OVERMIND_SOCKET}\" ]]; then\n        ${pkgs.overmind}/bin/overmind kill -s ${env.OVERMIND_SOCKET}\n      fi\n    '';\n\n    # SCRIPT - Start Server\n    startServer = pkgs.writeShellScriptBin \"startServer\" ''\n      OVERMIND_PROCFILE=${procfile}\n\n      if [[ -S \"${env.OVERMIND_SOCKET}\" ]]; then\n        exec ${stopServer}/bin/stopServer\n      fi\n\n      ${pkgs.overmind}/bin/overmind start \\\n        --procfile $OVERMIND_PROCFILE \\\n        --daemonize \\\n        --no-port \\\n        -s ${env.OVERMIND_SOCKET}\n    '';\n\n    # Packages\n    packages = with pkgs; [overmind caddy startServer stopServer];\n  in\n  {\n    devShell = pkgs.mkShell {\n      buildInputs = packages;\n\n      shellHook = ''\n        # Mark variables which are modified or created for export.\n        set -a\n        source ${toString ./env.txt}\n        set +a\n      '';\n    };\n  });\n}\n";
},"useData":true}